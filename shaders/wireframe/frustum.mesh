#version 460 core

#extension GL_EXT_mesh_shader : enable

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(lines, max_vertices = 8, max_primitives = 12) out;

struct Frustum {
    vec4 left;
    vec4 right;
    vec4 top;
    vec4 bottom;
    vec4 near;
    vec4 far;
};

layout(set = 0, binding = 0) uniform Camera {
    mat4 view;
    mat4 projection;
    mat4 inverseView;
    mat4 inverseProjection;
    mat4 flippedView;
    mat4 inverseFlippedView;
} camera;

layout(set = 1, binding = 0) readonly buffer FrustumBuffer {
    Frustum[] data;
} frustums;

layout(push_constant) uniform Model {
    mat4 matrix;
} model;

layout (location = 0) out PerVertexData {
    vec4 color;
} v_out[];

vec3 intersect3Planes(vec4 N1, vec4 N2, vec4 N3) {
    return -vec3(N1.w, N2.w, N3.w) * inverse(mat3(N1.xyz, N2.xyz, N3.xyz));
}

void main() {
    uint index = gl_WorkGroupID.x * gl_NumWorkGroups.y * gl_NumWorkGroups.z + gl_WorkGroupID.y * gl_NumWorkGroups.z + gl_WorkGroupID.z;

    Frustum frustum = frustums.data[index];

    vec4 near = vec4(frustum.near.xyz, -1.0);
    vec4 far = vec4(frustum.far.xyz, 5.0);

    vec3 PNearLeftDown = intersect3Planes(frustum.left, frustum.bottom, near);
    vec3 PNearRightDown = intersect3Planes(frustum.right, frustum.bottom, near);
    vec3 PNearRightUp = intersect3Planes(frustum.right, frustum.top, near);
    vec3 PNearLeftUp = intersect3Planes(frustum.left, frustum.top, near);

    vec3 PFarLeftDown = intersect3Planes(frustum.left, frustum.bottom, far);
    vec3 PFarRightDown = intersect3Planes(frustum.right, frustum.bottom, far);
    vec3 PFarRightUp = intersect3Planes(frustum.right, frustum.top, far);
    vec3 PFarLeftUp = intersect3Planes(frustum.left, frustum.top, far);

    for (uint i = 0; i < 8; i++) {
        v_out[i].color = vec4(1.0, 1.0, 1.0, 1.0);
    }

    gl_MeshVerticesEXT[0].gl_Position = camera.projection * camera.view * model.matrix * vec4(PNearLeftDown, 1.0);
    gl_MeshVerticesEXT[1].gl_Position = camera.projection * camera.view * model.matrix * vec4(PNearRightDown, 1.0);
    gl_MeshVerticesEXT[2].gl_Position = camera.projection * camera.view * model.matrix * vec4(PNearRightUp, 1.0);
    gl_MeshVerticesEXT[3].gl_Position = camera.projection * camera.view * model.matrix * vec4(PNearLeftUp, 1.0);
    gl_MeshVerticesEXT[4].gl_Position = camera.projection * camera.view * model.matrix * vec4(PFarLeftDown, 1.0);
    gl_MeshVerticesEXT[5].gl_Position = camera.projection * camera.view * model.matrix * vec4(PFarRightDown, 1.0);
    gl_MeshVerticesEXT[6].gl_Position = camera.projection * camera.view * model.matrix * vec4(PFarRightUp, 1.0);
    gl_MeshVerticesEXT[7].gl_Position = camera.projection * camera.view * model.matrix * vec4(PFarLeftUp, 1.0);

    gl_PrimitiveLineIndicesEXT[0] = uvec2(0, 1);
    gl_PrimitiveLineIndicesEXT[1] = uvec2(1, 2);
    gl_PrimitiveLineIndicesEXT[2] = uvec2(2, 3);
    gl_PrimitiveLineIndicesEXT[3] = uvec2(3, 0);
    gl_PrimitiveLineIndicesEXT[4] = uvec2(4, 5);
    gl_PrimitiveLineIndicesEXT[5] = uvec2(5, 6);
    gl_PrimitiveLineIndicesEXT[6] = uvec2(6, 7);
    gl_PrimitiveLineIndicesEXT[7] = uvec2(7, 4);
    gl_PrimitiveLineIndicesEXT[8] = uvec2(0, 4);
    gl_PrimitiveLineIndicesEXT[9] = uvec2(1, 5);
    gl_PrimitiveLineIndicesEXT[10] = uvec2(2, 6);
    gl_PrimitiveLineIndicesEXT[11] = uvec2(3, 7);

    SetMeshOutputsEXT(8, 12);
}