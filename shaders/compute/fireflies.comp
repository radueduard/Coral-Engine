#version 460 core

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Particle {
    vec4 position;
    vec4 color;
};

struct Trajectory {
    vec4 onCurve[4];
    vec4 controlPoints[8];
};

layout(set = 0, binding = 0) buffer Particles {
    Particle data[];
} particles;

layout(set = 0, binding = 1) readonly buffer Trajectories {
    Trajectory data[];
} trajectories;

layout(set = 0, binding = 2) uniform sampler2D heightMap;

layout(push_constant) uniform PushConstants {
    float timeElapsed;
    float deltaTime;
} pushConstants;

vec4 bezier (vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {
    float u = 1.0 - t;
    float tt = t * t;
    float uu = u * u;
    float uuu = uu * u;
    float ttt = tt * t;

    vec4 p = uuu * p0;
    p += 3.0 * uu * t * p1;
    p += 3.0 * u * tt * p2;
    p += ttt * p3;
    p.w = 0.0;
    return p;
}

void main() {
    uint index = gl_GlobalInvocationID.x;

    Particle particle = particles.data[index];
    Trajectory trajectory = trajectories.data[index];

    float t = mod(pushConstants.timeElapsed, 4.0);
    uint segment = uint(t);

    vec4 p0 = trajectory.onCurve[segment];
    vec4 p1 = trajectory.controlPoints[segment * 2 + 1];
    vec4 p2 = trajectory.controlPoints[(segment * 2 + 2) % 8];
    vec4 p3 = trajectory.onCurve[(segment + 1) % 4];

    float localT = fract(t);
    vec4 localPosition = bezier(p0, p1, p2, p3, localT);
    particle.position.xyz = localPosition.xyz;
    particle.position.y += max(0.0, texture(heightMap, (particle.position.xz / 15.0 + 1.0) / 2.0).r) + 1.0;

    if (particle.position.x > 15.0) {
        particle.position.x = -15.0;
    }
    if (particle.position.x < -15.0) {
        particle.position.x = 15.0;
    }
    if (particle.position.z > 15.0) {
        particle.position.z = -15.0;
    }
    if (particle.position.z < -15.0) {
        particle.position.z = 15.0;
    }

    particles.data[index] = particle;
}