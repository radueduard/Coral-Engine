#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

const uint elementsPerInvocation = 1024 / (gl_WorkGroupSize.x * gl_WorkGroupSize.y);

layout(set = 0, binding = 0) uniform Camera {
    mat4 view;
    mat4 projection;
    mat4 inverseView;
    mat4 inverseProjection;
    mat4 flippedView;
    mat4 inverseFlippedView;
} camera;

struct Particle {
    vec4 origin;    // vec2
    vec4 position;  // vec3
    vec4 color;
};

layout(set = 1, binding = 0) readonly buffer Particles {
    Particle data[];
} particles;

struct Indices {
    uint data[64];
};

layout(set = 1, binding = 1) writeonly buffer IndexBuffer {
    Indices data[];
} indexBuffer;

struct Frustum {
    vec4 left;
    vec4 right;
    vec4 top;
    vec4 bottom;
    vec4 near;
    vec4 far;
};

layout(set = 1, binding = 2) readonly buffer FrustumBuffer {
    Frustum[] data;
} frustums;

layout(set = 1, binding = 3) writeonly uniform image2D debugImage;
layout(set = 1, binding = 4) uniform sampler2D depthSampler;

layout(push_constant) uniform Model {
    mat4 matrix;
} model;

shared uint lightIndex;
shared Indices indices;

Frustum rotateToCamera(Frustum frustum) {
    Frustum result = frustum;
    result.left = vec4(mat3(model.matrix) * frustum.left.xyz, frustum.left.w);
    result.right = vec4(mat3(model.matrix) * frustum.right.xyz, frustum.right.w);
    result.top = vec4(mat3(model.matrix) * frustum.top.xyz, frustum.top.w);
    result.bottom = vec4(mat3(model.matrix) * frustum.bottom.xyz, frustum.bottom.w);
    result.near = vec4(mat3(model.matrix) * frustum.near.xyz, frustum.near.w);
    result.far = vec4(mat3(model.matrix) * frustum.far.xyz, frustum.far.w);
    return result;
}

bool isBehindPlane(vec4 planeNormal, vec3 positionOfObject, float radiusofObject) {
    vec3 cameraPosition = vec3(camera.inverseView[3]);
    vec3 relativePosition = positionOfObject - cameraPosition;
    return dot(planeNormal.xyz, relativePosition) + planeNormal.w + radiusofObject < 0;
}

bool isInsideFrustum(Frustum frustum, vec3 positionOfObject, float radiusofObject) {
    return !isBehindPlane(frustum.left, positionOfObject, radiusofObject) &&
           !isBehindPlane(frustum.right, positionOfObject, radiusofObject) &&
           !isBehindPlane(frustum.top, positionOfObject, radiusofObject) &&
           !isBehindPlane(frustum.bottom, positionOfObject, radiusofObject) &&
           !isBehindPlane(frustum.near, positionOfObject, radiusofObject) &&
           !isBehindPlane(frustum.far, positionOfObject, radiusofObject);
}

void main() {
    Frustum frustum = frustums.data[gl_WorkGroupID.x * gl_NumWorkGroups.y + (gl_NumWorkGroups.y - gl_WorkGroupID.y - 1)];
    frustum = rotateToCamera(frustum);

    if (gl_LocalInvocationIndex == 0) {
        lightIndex = 1;
    }
    barrier();

    uint start = gl_LocalInvocationIndex * elementsPerInvocation;
    uint end = start + elementsPerInvocation;
    for (uint i = start; i < end; i++) {
        if (lightIndex >= 64) {
            break;
        }
        Particle particle = particles.data[i];

        vec4 ndc = vec4(camera.projection * camera.view * vec4(particle.position.xyz, 1.0));
        vec2 screenPosition = ndc.xy / ndc.w;
        float depth = ndc.z / ndc.w;

        if (depth > texture(depthSampler, screenPosition).r + 0.01) {
            continue;
        }

        if (isInsideFrustum(frustum, particle.position.xyz, particle.position.w)) {
            uint id = atomicAdd(lightIndex, 1);
            indices.data[id] = i;
        }
    }
    barrier();

    if (gl_LocalInvocationIndex == 0) {
        indices.data[0] = lightIndex - 1;

        uint index = gl_WorkGroupID.x * gl_NumWorkGroups.y + gl_WorkGroupID.y;
        indexBuffer.data[index] = indices;

        float debugColor = float(lightIndex - 1) / (gl_WorkGroupSize.x * gl_WorkGroupSize.y);
        imageStore(debugImage, ivec2(gl_WorkGroupID.xy), vec4(debugColor, 0, 0, 1.0));
    }
}