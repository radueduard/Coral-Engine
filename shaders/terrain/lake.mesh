#version 460 core

#extension GL_EXT_mesh_shader : enable

layout(local_size_x = 3, local_size_y = 1, local_size_z = 3) in;
layout(triangles, max_vertices = 128, max_primitives = 256) out;

layout (set = 0, binding = 0) uniform Camera {
    mat4 view;
    mat4 projection;
    mat4 inverseView;
    mat4 inverseProjection;
    mat4 flippedView;
    mat4 incerseFlippedView;
} camera;

layout (location = 0) out PerVertexData {
    vec4 position;
    vec4 ndcPosition;
    vec3 normal;
    vec2 uv;
} v_out[];

const float patchSize = .1;
const uint vertexPerLinePerInstance = 3;
const uint vertexPerInstance = vertexPerLinePerInstance * vertexPerLinePerInstance;
const uint vertexPerPatch = vertexPerInstance * gl_WorkGroupSize.x * gl_WorkGroupSize.z;

const uint trianglePerLinePerInstance = vertexPerLinePerInstance - 1;
const uint trianglePerInstance = trianglePerLinePerInstance * trianglePerLinePerInstance;
const uint trianglePerPatch = trianglePerInstance * gl_WorkGroupSize.x * gl_WorkGroupSize.z;

void main() {
    const vec3 anchor = -vec3(
    float(gl_NumWorkGroups.x * gl_WorkGroupSize.x),
    0.0,
    float(gl_NumWorkGroups.z * gl_WorkGroupSize.z)) / 2;

    const vec3 maxPosition = (anchor + vec3(gl_NumWorkGroups.x * gl_WorkGroupSize.x, 0.0, gl_NumWorkGroups.z * gl_WorkGroupSize.z)) * patchSize;

    for (uint i = 0; i < vertexPerLinePerInstance; i++) {
        for (uint j = 0; j < vertexPerLinePerInstance; j++) {
            uint localIndex = i * vertexPerLinePerInstance + j;
            uint index = vertexPerInstance * gl_LocalInvocationIndex + localIndex;

            vec3 positionInInstance = vec3(i, 0.0, j) / float(vertexPerLinePerInstance - 1);
            vec3 position = (anchor + positionInInstance + vec3(gl_GlobalInvocationID.x, 0.0, gl_GlobalInvocationID.z)) * patchSize;

            v_out[index].position = vec4(position, 1.0);
            vec4 ndc = vec4(camera.projection * camera.view * vec4(position, 1.0));
            v_out[index].ndcPosition = ndc / ndc.w;
            v_out[index].normal = vec3(0.0, 1.0, 0.0);
            v_out[index].uv = (position.xz / maxPosition.xz + 1.0) / 2.0;
        }
    }

    barrier();

    for (uint i = 0; i < trianglePerLinePerInstance; i++) {
        for (uint j = 0; j < trianglePerLinePerInstance; j++) {
            uint index = i * trianglePerLinePerInstance + j + trianglePerInstance * gl_LocalInvocationIndex;

            uvec3 triangle1 = uvec3(
                vertexPerInstance * gl_LocalInvocationIndex + i * vertexPerLinePerInstance + j,
                vertexPerInstance * gl_LocalInvocationIndex + i * vertexPerLinePerInstance + j + 1,
                vertexPerInstance * gl_LocalInvocationIndex + (i + 1) * vertexPerLinePerInstance + j
            );

            uvec3 triangle2 = uvec3(
                vertexPerInstance * gl_LocalInvocationIndex + i * vertexPerLinePerInstance + j + 1,
                vertexPerInstance * gl_LocalInvocationIndex + (i + 1) * vertexPerLinePerInstance + j + 1,
                vertexPerInstance * gl_LocalInvocationIndex + (i + 1) * vertexPerLinePerInstance + j
            );

            gl_PrimitiveTriangleIndicesEXT[index] = triangle1;
            gl_PrimitiveTriangleIndicesEXT[index + trianglePerPatch] = triangle2;
        }
    }

    barrier();

    for (uint i = vertexPerInstance * gl_LocalInvocationIndex; i < vertexPerInstance * (gl_LocalInvocationIndex + 1); i++) {
        gl_MeshVerticesEXT[i].gl_Position = camera.projection * camera.view * v_out[i].position;
    }

    SetMeshOutputsEXT(vertexPerPatch, trianglePerPatch * 2);
}

