#version 460 core

#extension GL_EXT_mesh_shader : enable

layout(local_size_x = 3, local_size_y = 1, local_size_z = 3) in;
layout(triangles, max_vertices = 128, max_primitives = 256) out;

layout (push_constant) uniform PushConstants {
    mat4 View;
    mat4 Projection;
} pushConstants;

layout (set = 0, binding = 0) uniform sampler2D heightMap;
layout (set = 0, binding = 1) uniform Settings {
    float maxHeight;
    float patchSize;
    vec4 lodWeights[4];
} settings;

layout (location = 0) out PerVertexData {
    vec4 position;
    vec3 normal;
    vec2 uv;
} v_out[];

const uint vertexPerLinePerInstance = 3;
const uint vertexPerInstance = vertexPerLinePerInstance * vertexPerLinePerInstance;
const uint vertexPerPatch = vertexPerInstance * gl_WorkGroupSize.x * gl_WorkGroupSize.z;

const uint trianglePerLinePerInstance = vertexPerLinePerInstance - 1;
const uint trianglePerInstance = trianglePerLinePerInstance * trianglePerLinePerInstance;
const uint trianglePerPatch = trianglePerInstance * gl_WorkGroupSize.x * gl_WorkGroupSize.z;

float SampleFunction(vec2 uv) {
    float d = length(uv);
    float height = (1 + tanh(d * 12 - 4)) * settings.maxHeight / 2;
    uv = (uv + 1.0) / 2.0;

    for (int i = 0; i < 10; i++) {
        height += (textureLod(heightMap, uv, i).r -.5f) * settings.maxHeight * settings.lodWeights[i / 4][i % 4] * 4;
    }
    
    return height;
}

vec3 ComputeNormal(vec2 uv) {
    float hL = SampleFunction(uv + vec2(-settings.patchSize / vertexPerLinePerInstance, 0.0));
    float hR = SampleFunction(uv + vec2(settings.patchSize / vertexPerLinePerInstance, 0.0));
    float hD = SampleFunction(uv + vec2(0.0, -settings.patchSize / vertexPerLinePerInstance));
    float hU = SampleFunction(uv + vec2(0.0, settings.patchSize / vertexPerLinePerInstance));
    return normalize(vec3(hL - hR, 2.0, hD - hU));
}

void main() {
    const vec3 anchor = -vec3(
        float(gl_NumWorkGroups.x * gl_WorkGroupSize.x),
        0.0,
        float(gl_NumWorkGroups.z * gl_WorkGroupSize.z)) / 2;

    const vec3 maxPosition = (anchor + vec3(gl_NumWorkGroups.x * gl_WorkGroupSize.x, 0.0, gl_NumWorkGroups.z * gl_WorkGroupSize.z)) * settings.patchSize;

    for (uint i = 0; i < vertexPerLinePerInstance; i++) {
        for (uint j = 0; j < vertexPerLinePerInstance; j++) {
            uint localIndex = i * vertexPerLinePerInstance + j;
            uint index = vertexPerInstance * gl_LocalInvocationIndex + localIndex;

            vec3 positionInInstance = vec3(i, 0.0, j) / float(vertexPerLinePerInstance - 1);
            vec3 position = (anchor + positionInInstance + vec3(gl_GlobalInvocationID.x, 0.0, gl_GlobalInvocationID.z)) * settings.patchSize;
            position.y = SampleFunction(position.xz / maxPosition.xz);

            v_out[index].position = vec4(position, 1.0);
            v_out[index].normal = ComputeNormal(position.xz / maxPosition.xz);
            v_out[index].uv = positionInInstance.xz;
        }
    }

    barrier();

    for (uint i = 0; i < trianglePerLinePerInstance; i++) {
        for (uint j = 0; j < trianglePerLinePerInstance; j++) {
            uint index = i * trianglePerLinePerInstance + j + trianglePerInstance * gl_LocalInvocationIndex;

            uvec3 triangle1 = uvec3(
                vertexPerInstance * gl_LocalInvocationIndex + i * vertexPerLinePerInstance + j,
                vertexPerInstance * gl_LocalInvocationIndex + i * vertexPerLinePerInstance + j + 1,
                vertexPerInstance * gl_LocalInvocationIndex + (i + 1) * vertexPerLinePerInstance + j
            );

            uvec3 triangle2 = uvec3(
                vertexPerInstance * gl_LocalInvocationIndex + i * vertexPerLinePerInstance + j + 1,
                vertexPerInstance * gl_LocalInvocationIndex + (i + 1) * vertexPerLinePerInstance + j + 1,
                vertexPerInstance * gl_LocalInvocationIndex + (i + 1) * vertexPerLinePerInstance + j
            );

            gl_PrimitiveTriangleIndicesEXT[index] = triangle1;
            gl_PrimitiveTriangleIndicesEXT[index + trianglePerPatch] = triangle2;
        }
    }

    barrier();

    for (uint i = vertexPerInstance * gl_LocalInvocationIndex; i < vertexPerInstance * (gl_LocalInvocationIndex + 1); i++) {
        gl_MeshVerticesEXT[i].gl_Position = pushConstants.Projection * pushConstants.View * v_out[i].position;
    }

    SetMeshOutputsEXT(vertexPerPatch, trianglePerPatch * 2);
}

