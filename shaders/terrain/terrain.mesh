#version 460 core

#extension GL_EXT_mesh_shader : enable

layout(local_size_x = 3, local_size_y = 1, local_size_z = 3) in;
layout(triangles, max_vertices = 128, max_primitives = 256) out;

layout (push_constant) uniform PushConstants {
    mat4 ViewProjection;
} pushConstants;

layout (set = 0, binding = 0) uniform sampler2D heightMap;

layout (location = 0) out PerVertexData {
    vec4 position;
    vec3 normal;
    vec2 uv;
} v_out[];

const float patchSize = .1;
const uint vertexPerLinePerInstance = 3;
const uint vertexPerInstance = vertexPerLinePerInstance * vertexPerLinePerInstance;
const uint vertexPerPatch = vertexPerInstance * gl_WorkGroupSize.x * gl_WorkGroupSize.z;

const uint trianglePerLinePerInstance = vertexPerLinePerInstance - 1;
const uint trianglePerInstance = trianglePerLinePerInstance * trianglePerLinePerInstance;
const uint trianglePerPatch = trianglePerInstance * gl_WorkGroupSize.x * gl_WorkGroupSize.z;

float SampleFunction(vec2 uv) {
    float hmax = 5.0;
    float d = length(uv);
    float height =
    uv = (uv + 1.0) / 2.0;

    float h0 = textureLod(heightMap, uv, 0).r * hmax / 128.0 - hmax / 128.0 / 2.0;
    float h1 = textureLod(heightMap, uv, 1).r * hmax / 64.0 - hmax / 64.0 / 2.0;
    float h2 = textureLod(heightMap, uv, 2).r * hmax / 32.0 - hmax / 32.0 / 2.0;
    float h3 = textureLod(heightMap, uv, 3).r * hmax / 16.0 - hmax / 16.0 / 2.0;
    float h4 = textureLod(heightMap, uv, 4).r * hmax / 8.0 - hmax / 8.0 / 2.0;
    float h5 = textureLod(heightMap, uv, 5).r * hmax / 4.0 - hmax / 4.0 / 2.0;
    float h6 = textureLod(heightMap, uv, 6).r * hmax / 2.0 - hmax / 2.0 / 2.0;
    float h7 = textureLod(heightMap, uv, 7).r * hmax * 1.0 - hmax * 1.0 / 2.0;
    float h8 = textureLod(heightMap, uv, 8).r * hmax * 2.0 - hmax * 2.0 / 2.0;
    float h9 = textureLod(heightMap, uv, 9).r * hmax * 4.0 - hmax * 4.0 / 2.0;
    return height + h0 + h1 + h2 + h3 + h4 + h5 + h6 + h7 + h8 + h9;
}

vec3 ComputeNormal(vec2 uv) {
    float hL = SampleFunction(uv + vec2(-patchSize / vertexPerLinePerInstance, 0.0));
    float hR = SampleFunction(uv + vec2(patchSize / vertexPerLinePerInstance, 0.0));
    float hD = SampleFunction(uv + vec2(0.0, -patchSize / vertexPerLinePerInstance));
    float hU = SampleFunction(uv + vec2(0.0, patchSize / vertexPerLinePerInstance));
    return normalize(vec3(hL - hR, 2.0, hD - hU));
}

void main() {
    const vec3 anchor = -vec3(
        float(gl_NumWorkGroups.x * gl_WorkGroupSize.x),
        0.0,
        float(gl_NumWorkGroups.z * gl_WorkGroupSize.z)) / 2;

    const vec3 maxPosition = (anchor + vec3(gl_NumWorkGroups.x * gl_WorkGroupSize.x, 0.0, gl_NumWorkGroups.z * gl_WorkGroupSize.z)) * patchSize;

    for (uint i = 0; i < vertexPerLinePerInstance; i++) {
        for (uint j = 0; j < vertexPerLinePerInstance; j++) {
            uint localIndex = i * vertexPerLinePerInstance + j;
            uint index = vertexPerInstance * gl_LocalInvocationIndex + localIndex;

            vec3 positionInInstance = vec3(i, 0.0, j) / float(vertexPerLinePerInstance - 1);
            vec3 position = (anchor + positionInInstance + vec3(gl_GlobalInvocationID.x, 0.0, gl_GlobalInvocationID.z)) * patchSize;
            position.y = SampleFunction(position.xz / maxPosition.xz);

            v_out[index].position = vec4(position, 1.0);
            v_out[i].normal = ComputeNormal(v_out[i].position.xz / maxPosition.xz);
            v_out[index].uv = positionInInstance.xz;
        }
    }

    barrier();

    for (uint i = 0; i < trianglePerLinePerInstance; i++) {
        for (uint j = 0; j < trianglePerLinePerInstance; j++) {
            uint index = i * trianglePerLinePerInstance + j + trianglePerInstance * gl_LocalInvocationIndex;

            uvec3 triangle1 = uvec3(
                vertexPerInstance * gl_LocalInvocationIndex + i * vertexPerLinePerInstance + j,
                vertexPerInstance * gl_LocalInvocationIndex + i * vertexPerLinePerInstance + j + 1,
                vertexPerInstance * gl_LocalInvocationIndex + (i + 1) * vertexPerLinePerInstance + j
            );

            uvec3 triangle2 = uvec3(
                vertexPerInstance * gl_LocalInvocationIndex + i * vertexPerLinePerInstance + j + 1,
                vertexPerInstance * gl_LocalInvocationIndex + (i + 1) * vertexPerLinePerInstance + j + 1,
                vertexPerInstance * gl_LocalInvocationIndex + (i + 1) * vertexPerLinePerInstance + j
            );

            gl_PrimitiveTriangleIndicesEXT[index] = triangle1;
            gl_PrimitiveTriangleIndicesEXT[index + trianglePerPatch] = triangle2;
        }
    }

    barrier();

    for (uint i = vertexPerInstance * gl_LocalInvocationIndex; i < vertexPerInstance * (gl_LocalInvocationIndex + 1); i++) {
        gl_MeshVerticesEXT[i].gl_Position = pushConstants.ViewProjection * v_out[i].position;
    }

    SetMeshOutputsEXT(vertexPerPatch, trianglePerPatch * 2);
}

